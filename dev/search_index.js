var documenterSearchIndex = {"docs":
[{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The first step to using DirectDetections.jl is to install Julia. If you're used to Python, don't worry –- Julia is easy to install, and you won't need to code anything other than changing your input data.","category":"page"},{"location":"getting-started/#Installing-Julia","page":"Getting Started","title":"Installing Julia","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Visit the julialang.org Downloads page, and select the latest stable version for your operating system. Currently, this is 1.7.0. Click the [help] links next to your operating system if you require more detailed instructions.","category":"page"},{"location":"getting-started/#Installing-PlanetOrbits","page":"Getting Started","title":"Installing PlanetOrbits","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Normally, Julia packages are installed from the General registry. Since PlanetOrbits isn't quite ready for prime time, it requires one extra step to add an additional registry.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Start julia in a terminal by running julia\nType ] to enter package-mode (see Julia documentation for more details)\nType up to setup the General registry if this is your first time using Julia.\nType registry add https://github.com/sefffal/DirectRegistry\nType add PlanetOrbits","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If you would like to visualize your results, you can also install the Plots package:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Type add Plots","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This will take a little while to download all the required packages and precompile for your system.","category":"page"},{"location":"getting-started/#Plotting-your-first-orbit","page":"Getting Started","title":"Plotting your first orbit","text":"","category":"section"},{"location":"plots/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"This package defines Plots.jl recipes for orbits and orbit solutions. At its most basic, you can simply call plot on the object. The kind  of plot will be based on the type of object. You can pass the kind argument to control what plot is generated.","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"Examples:","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"using PlanetOrbits, Plots\norb = orbit(\n    a=1.0,\n    M=1.0,\n)\nplot(orb) # defaults to kind=:radvel","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"orb = orbit(\n    a=1.0,\n    M=1.0,\n    i=0.5,\n    Ω=4.5\n)\nplot(orb) # defaults to kind=(:x,:y)","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"orb = orbit(\n    a=1.0,\n    M=1.0,\n    i=0.5,\n    Ω=4.5,\n    plx=120.0,\n    tp=mjd(\"2024-03-01\")\n)\nplot(orb) # defaults to kind=:astrom","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"We can override:","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"plot(orb, kind=:radvel)","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"plot(orb, kind=(:x,:y))","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"plot(orb, kind=(:x,:z))","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"plot(orb, kind=(:x,:y,:z))","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"They all work on a given orbit solution as well:","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"sol = orbitsolve(orb, mjd(\"2020-01-01\"))\nplot(sol, kind=:radvel)","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"plot(sol, kind=(:x,:y))","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"plot(sol, kind=(:x,:z))","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"plot(sol, kind=(:x,:y,:z))","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"Note, in GR the position of the marker in 3D plots is incorrect. Try the plotly() backend instead.","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"The plots are generated by tracing out the orbit in equal steps of mean anomaly.  Compared to taking equal steps in time, this gives smooth lines even for very highly eccentric orbits.","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"The plot recipe sets the axes to have default aspect ratios and flips the right-ascension (horizontal) axis to increasing towards the left as it does when viewed in the plane of the sky.","category":"page"},{"location":"plots/#Plotting-multiple-orbits","page":"Plotting","title":"Plotting multiple orbits","text":"","category":"section"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"If you have an array of Keplerian orbits, you can plot them all in one go:","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"elements = [orbit(a=16+0.3i, i=deg2rad(i), e=0.25+0.001i, τ=0, M=1, ω=0, Ω=120, plx=35) for i in 1:1:90]\nplot(elements, color=1)","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"This recipe scales down the opacity slightly so that you can see where the orbits overlap. Override by passing alpha=1.","category":"page"},{"location":"plots/#Animations","page":"Plotting","title":"Animations","text":"","category":"section"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"You can use the Plots.jl @gif and @animate macros to create animations using a for loop.","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"orb = orbit(a=1.2, e=0.4, M=1.0, ω=π/2, τ=0.0, i=π/4, Ω=0,plx=100)\n@gif for t in range(0, period(orb),length=30)\n    sol = orbitsolve(orb,t)\n    plot(\n        plot(sol,kind=(:raoff,:decoff),body=(:primary,:secondary),mass=0.2,legend=false,title=\"astrometry\"),\n        plot(sol,kind=(:pmra,:pmdec),body=(:primary,:secondary),mass=0.2,title=\"proper motion anomaly\"),\n        plot(sol,kind=(:accra,:accdec),body=(:primary,:secondary),mass=0.2,legend=false,title=\"astrometric acceleration\"),\n        plot(sol,kind=(:t,:radvel), tspan=(-300,300), body=(:primary,:secondary),mass=0.2,legend=false,title=\"radial velocity\"),\n        lims=:symmetric,\n        framestyle=:box, titlefontsize=10,guidefontsize=7,tickfontsize=7\n    )\nend","category":"page"},{"location":"plots/#Logo","page":"Plotting","title":"Logo","text":"","category":"section"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"To get more ideas for plotting, check out this example which generates an animated version of the logo for this page.","category":"page"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"(Image: orbit logo)","category":"page"},{"location":"image-warping/#Image-Warping","page":"Image Warping","title":"Image Warping","text":"","category":"section"},{"location":"image-warping/","page":"Image Warping","title":"Image Warping","text":"warning: Warning\nThis functionality is currently not working and could use some attention in the form of pull request.","category":"page"},{"location":"image-warping/","page":"Image Warping","title":"Image Warping","text":"If you have an image of a system, you can warp the image as if each pixel were a test particle following Kepler's laws.  This is an easy way to see what a disk or a system of planets would look like at a time other than when it was captured.","category":"page"},{"location":"image-warping/","page":"Image Warping","title":"Image Warping","text":"To make this possible, PlanetOrbits.jl can create OrbitalTransformation objects. These follow the conventions set out in CoordinateTransformations.jl and are compatible with ImageTransformations.jl.","category":"page"},{"location":"image-warping/","page":"Image Warping","title":"Image Warping","text":"Example:","category":"page"},{"location":"image-warping/","page":"Image Warping","title":"Image Warping","text":"using ImageTransformations, AstroImages, CoordinateTransformations\not = OrbitalTransformation(\n    i = 0.3,\n    e = 0.0,\n    M = 1.0,\n    ω = 0.5,\n    Ω = 0.5,\n    plx = 300.0,\n    \n    platescale=10.0, # mas/px\n    dt = 3*365.25 # days forward in time\n)\n\nimg = load(\"input.fits\")\n\ntform_centered = ImageTransformations.recenter(ot, ImageTransformations.center(img))\nimg_future = warp(img_centered, ot, axes(img_centered))\n\n# Display with AstroImages.jl\nimview([img; img_future], cmap=:seaborn_icefire_gradient)","category":"page"},{"location":"image-warping/","page":"Image Warping","title":"Image Warping","text":"Before, and After Orbital Transformation","category":"page"},{"location":"image-warping/","page":"Image Warping","title":"Image Warping","text":"(Image: image)","category":"page"},{"location":"image-warping/","page":"Image Warping","title":"Image Warping","text":"Note the arguments platescale and dt are required, but a and τ are not. The position of the pixel in X/Y space uniquely determines the semi-major axis and epoch of periastron passage when the rest of the orbital parameters are known. platescale in units of milliarseconds/pixel is necessary to get the overall scale of the transform correct. This is because an orbital transformation is not linear (and therefore, care must be taken when composing an OrbitalTransformation with other CoordinateTransformations). Scaling an image will change the amount of rotation that occurs at each separation. dt is the the amount of time in days to project the image forward. It can also be negative to project the image into the past. ","category":"page"},{"location":"symbolics/#Symbolic-Manipulation","page":"Symbolic Manipulation","title":"Symbolic Manipulation","text":"","category":"section"},{"location":"symbolics/","page":"Symbolic Manipulation","title":"Symbolic Manipulation","text":"The Symbolics.jl package works fairly well out of the box with PlanetOrbits.jl. You can create fully or partially symbolic KepOrbit and/or solve for orbits at a time or true anomaly given by a symbolic t. This could come in use in a few scenarios. For example, if you have an orbit with all parameters known except inclination, you could construct a set of elements with i as a symbolic variable. Solving the orbit using orbitsolve would then return a solution with simplified symbolic expressions of i that can be evaluated very efficiently for different values. N.B. this approach is quite messy for a symbolic e since Kepler's equation is trancendental.","category":"page"},{"location":"symbolics/","page":"Symbolic Manipulation","title":"Symbolic Manipulation","text":"There is some support for using the Symbolics.jl package. You can create symbolic variables and trace most of the functions defined in this package to get symbolic expressions.  This is a little slow, and I'm not sure of the applications, but it's neat that it works.","category":"page"},{"location":"symbolics/","page":"Symbolic Manipulation","title":"Symbolic Manipulation","text":"using Symbolics\n@variables t\nexpr = radvel(elements, t);","category":"page"},{"location":"symbolics/","page":"Symbolic Manipulation","title":"Symbolic Manipulation","text":"This works with the VisualOrbit constructors as well if you want to create a full symbolic set of elements.","category":"page"},{"location":"api/#API-Documentation","page":"API","title":"API Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following tables show what functions are supported for what kind of orbit. If you're not sure yet what kind of orbit to use, just use the orbit function! ✅ indiciates that a function is available, and ❌ indicates it is not due to the orbit not storing sufficient information. ⚠️ indicates that it could be supoprted, but is not yet implemented.","category":"page"},{"location":"api/#Required-Parameters","page":"API","title":"Required Parameters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following table specifies what properties are required to construct each orbit type. Based on this information, different orbit types have different capabilities (described in following tables).","category":"page"},{"location":"api/","page":"API","title":"API","text":"property meaning KepOrbit Visual{KepOrbit} AbsoluteVisual{KepOrbit} ThieleInnesOrbit RadialVelocityOrbit CartesianOrbit Visual{CartesianOrbit}\nM  ✔️ ✔️ ✔️ ✔️ ✔️ ✔️ ✔️\nplx   ✔️ ✔️ ✔️   ✔️\ntp  ✔️ ✔️ ✔️ ✔️ ✔️ ✔️ ✔️\ntref  ✔️ ✔️ ✔️ ✔️ ✔️ ✔️ ✔️\ne  ✔️ ✔️ ✔️ ✔️ ✔️  \ni  ✔️ ✔️ ✔️    \nω  ✔️ ✔️ ✔️  ✔️  \nΩ  ✔️ ✔️ ✔️    \nA     ✔️   \nB     ✔️   \nF     ✔️   \nG     ✔️   \nx       ✔️ ✔️\ny       ✔️ ✔️\nz       ✔️ ✔️\nvx       ✔️ ✔️\nvy       ✔️ ✔️\nvz       ✔️ ✔️\nref_epoch    ✔️    \nra    ✔️    \ndec    ✔️    \nrv    ✔️    \npmra    ✔️    \npmdec    ✔️    ","category":"page"},{"location":"api/#Properties-of-Orbits","page":"API","title":"Properties of Orbits","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"You can use these functions like totalmass(orbit).","category":"page"},{"location":"api/","page":"API","title":"API","text":"Function KepOrbit Visual{KepOrbit} ThieleInnesOrbit RadialVelocityOrbit CartesianOrbit Visual{CartesianOrbit}\ntotalmass ✅ ✅ ✅ ✅ ✅ ✅\nperiod ✅ ✅ ✅ ✅ ✅ ✅\ndistance ❌ ✅ ✅ ❌ ❌ ✅\nmeanmotion ✅ ✅ ✅ ✅ ✅ ✅\neccentricity ✅ ✅ ✅ ✅ ✅ ✅\ninclination ✅ ✅ ✅ ❌ ✅ ✅\nsemimajoraxis ✅ ✅ ✅ ✅ ✅ ✅\nperiastron ✅ ✅ ✅ ✅ ✅ ✅\nsemiamplitude ✅ ✅ ⚠️ ✅ ✅ ✅","category":"page"},{"location":"api/#Properties-of-Orbit-Solutions","page":"API","title":"Properties of Orbit Solutions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"You can use these functions like sol = orbitsolve(orbit,mjd(\"2020-01\")); posx(sol) or  posx(orbit, mjd(\"2020-01\")).","category":"page"},{"location":"api/","page":"API","title":"API","text":"Function KepOrbit Visual{KepOrbit} ThieleInnesOrbit RadialVelocityOrbit CartesianOrbit Visual{CartesianOrbit}\nmeananom ✅ ✅ ✅ ✅ ✅ ✅\ntrueanom ✅ ✅ ✅ ✅ ✅ ✅\neccanom ✅ ✅ ✅ ✅ ✅ ✅\nposx ✅ ✅ ✅ ❌ ✅ ✅\nposy ✅ ✅ ✅ ❌ ✅ ✅\nposz ✅ ✅ ✅ ❌ ✅ ✅\nvelx ✅ ✅ ✅ ❌ ✅ ✅\nvely ✅ ✅ ✅ ❌ ✅ ✅\nvelz ✅ ✅ ✅ ✅ ✅ ✅\nraoff ❌ ✅ ✅ ❌ ❌ ✅\ndecoff ❌ ✅ ✅ ❌ ❌ ✅\nradvel ✅ ✅ ✅ ✅ ✅ ✅\nposangle ✅ ✅ ✅ ❌ ✅ ✅\npmra ❌ ✅ ✅ ❌ ❌ ✅\npmdec ❌ ✅ ✅ ❌ ❌ ✅\naccra ❌ ✅ ❌ ❌ ❌ ⚠️\naccdec ❌ ✅ ❌ ❌ ❌ ⚠️","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/#PlanetOrbits.AbsoluteVisual","page":"API","title":"PlanetOrbits.AbsoluteVisual","text":"AbsoluteVisual{OrbitType}(..., ref_epoch=, ra=, dec=, plx=, rv=, pmra=, pmdec=)\n\nThis wraps another orbit object to add parallax, proper motion, and RV fields, at a given reference epoch. \n\nLike a Visual{OrbitType} this allows for calculating projected quantities, eg. separation in milliarcseconds.\n\nWhat this type additionally does is correct for the star's 3D motion through space (RV and proper motion) and differential light travel-time compared to a reference epoch when calculating various quantities.  This becomes necessary when computing eg. RVs over a long time period.\n\nra        : degrees dec       : degrees parallax  : mas pmra      : mas/yr pmdec     : mas/yr rv        : m/s ref_epoch : years\n\nTODO: account for viewing angle differences and differential light travel time between a planet and its host.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.AbsoluteVisualOrbit","page":"API","title":"PlanetOrbits.AbsoluteVisualOrbit","text":"AbsoluteVisual{OrbitType}(..., ref_epoch=, ra=, dec=, plx=, rv=, pmra=, pmdec=)\n\nThis wraps another orbit object to add parallax, proper motion, and RV fields, at a given reference epoch. \n\nLike a Visual{OrbitType} this allows for calculating projected quantities, eg. separation in milliarcseconds.\n\nWhat this type additionally does is correct for the star's 3D motion through space (RV and proper motion) and differential light travel-time compared to a reference epoch when calculating various quantities.  This becomes necessary when computing eg. RVs over a long time period.\n\nra        : degrees dec       : degrees plx       : mas pmra      : mas/yr pmdec     : mas/yr rv        : m/s ref_epoch : days\n\nTODO: account for viewing angle differences and differential light travel time between a planet and its host.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.AbstractOrbit","page":"API","title":"PlanetOrbits.AbstractOrbit","text":"AbstractOrbit\n\nRepresents a orbit. Contains all the information to calculate the location of a planet at a given time, true anomaly, eccentric anomaly, or mean anomaly. Different concrete implementations of AbstractOrbit contain varying amounts of information.\n\nBasic information about the orbit can be queried using functions like period(orbit).\n\nOrbits can be solved using functions like orbitsolve(orb).\n\nSee: RadialVelocityOrbit, KepOrbit, VisualOrbit\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.AbstractOrbitSolution","page":"API","title":"PlanetOrbits.AbstractOrbitSolution","text":"AbstractOrbitSolution\n\nRepresents the solution of an orbit. Contains all the information of an AbstractOrbit, plus information necessary to uniquely locate a planet.\n\nThe solution can be queried using a variety of functions such as radvel(solution).\n\nThe API for creating orbit solutions it not considered public as the fields may change between minor versions. Instead, create solutions only through the public orbitsolve and orbitsolve_... functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.Auto","page":"API","title":"PlanetOrbits.Auto","text":"PlanetOrbits.Auto()\n\nAutomatic choice of Kepler solver algorithm. Currently defaults to PlanetOrbits.Markley()\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.CartesianOrbit","page":"API","title":"PlanetOrbits.CartesianOrbit","text":"This constructor assumes that 1 year, 1 AU, and 1 solar mass are compatible. According to IAU definitions, they are not. Use with care where high precision is needed.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.CartesianOrbit-Tuple{AbstractOrbitSolution}","page":"API","title":"PlanetOrbits.CartesianOrbit","text":"Convert an existing orbit object to a CartesianOrbit. \n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.Goat","page":"API","title":"PlanetOrbits.Goat","text":"PlanetOrbits.Goat()\n\nKepler solver implementation from https://arxiv.org/abs/2103.15829 and https://github.com/oliverphilcox/Keplers-Goat-Herd\n\nIt is here for comparison purposes only. In general, Markley() is more performant and accurate.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.KepOrbit","page":"API","title":"PlanetOrbits.KepOrbit","text":"KepOrbit(\n    a, # semi-major axis [AU]\n    e, # eccentricity\n    i, # inclination [rad]\n    ω, # argument of periapsis [rad]\n    Ω, # longitude of ascending node [rad]\n    tp, # epoch of periastron passage at MJD=0\n    M, # mass of primary [M⊙]\n)\n\nRepresents the Keplerian elements of a secondary body orbiting a primary. Use the traditional Campbell parameterization. Values can be specified by keyword argument or named tuple for convenience.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.Markley","page":"API","title":"PlanetOrbits.Markley","text":"PlanetOrbits.Markley()\n\nKepler solver implementation from AstroLib, based on Markley (1995) Celestial Mechanics and Dynamical Astronomy, 63, 101 (DOI:10.1007/BF00691917). \n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.OrbitSolutionCartesian","page":"API","title":"PlanetOrbits.OrbitSolutionCartesian","text":"Represents a CartesianOrbit evaluated to some position.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.OrbitSolutionKep","page":"API","title":"PlanetOrbits.OrbitSolutionKep","text":"Represents a KepOrbit evaluated to some position.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.OrbitSolutionRadialVelocity","page":"API","title":"PlanetOrbits.OrbitSolutionRadialVelocity","text":"Represents a RadialVelocityOrbit evaluated to some position.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.OrbitSolutionThieleInnes","page":"API","title":"PlanetOrbits.OrbitSolutionThieleInnes","text":"Represents a ThieleInnesOrbit evaluated to some position.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.RadialVelocityOrbit","page":"API","title":"PlanetOrbits.RadialVelocityOrbit","text":"RadialVelocityOrbit(a, e, ω, tp, M)\n\nRepresents an orbit of a planet with only the information retrievable from radial velocity measurements. That is, without inclination, longitude of ascending node, or distance to the system.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.RootsMethod","page":"API","title":"PlanetOrbits.RootsMethod","text":"PlanetOrbits.RootsMethod(method::Roots.PlanetOrbits.Roots.AbstractUnivariateZeroMethod, kwargs...)\n\nWraps a root finding method from Roots.jl. Requires Roots to be loaded first. You can also pass keyword arguments that will be forwarded to Roots to control the tolerance.\n\nExamples:\n\nmethod = PlanetOrbits.RootsMethod(Roots.Newton())\nmethod = PlanetOrbits.RootsMethod(Roots.Thukral5B())\nmethod = PlanetOrbits.RootsMethod(Roots.Bisection())\nmethod = PlanetOrbits.RootsMethod(Roots.A42())\nmethod = PlanetOrbits.RootsMethod(Roots.Newton(), rtol=1e-3, atol=1e-3)\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.ThieleInnesOrbit","page":"API","title":"PlanetOrbits.ThieleInnesOrbit","text":"ThieleInnesOrbit(e, tp, M, plx, A, B, F, G)\n\nRepresents a visual orbit of a planet using Thiele-Innes orbital elements. Convertable to and from a VisualOrbit. This parameterization does not have the issue that traditional angular parameters have where the argument of periapsis and longitude of ascending node become undefined for circular and face on orbits respectively.\n\nwarning: Warning\nThere is a remaining bug in this implementation for pi <= Ω < 2pi\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.Visual","page":"API","title":"PlanetOrbits.Visual","text":"Visual{OrbitType}(..., plx=...)\n\nThis wraps another orbit to add the parallax distance field plx, thus allowing projected quantities to be calculated. It forwards everything else to the parent orbit.\n\nFor example, the KepOrbit type supports calculating x and y positions in AU. A Visual{KepOrbit} additionally supports calculating projected right ascension and declination offsets.\n\nnote: Note\nThe ThieleInnesOrbit type does not need to be wrapped in Visual as it the Thiele-Innes constants are already expressed in milliarcseconds and thus it always requires a plx value.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.VisualOrbit","page":"API","title":"PlanetOrbits.VisualOrbit","text":"Visual{OrbitType}(..., plx=...)\n\nThis wraps another orbit to add the parallax distance field plx, thus allowing projected quantities to be calculated. It forwards everything else to the parent orbit.\n\nFor example, the KepOrbit type supports calculating x and y positions in AU. A Visual{KepOrbit} additionally supports calculating projected right ascension and declination offsets.\n\nNote: the ThieleInnesOrbit type does not need to be wrapped in Visual as it the Thiele-Innes constants are already expressed in milliarcseconds and thus it always requires a plx value.\n\n\n\n\n\n","category":"type"},{"location":"api/#PlanetOrbits.accdec","page":"API","title":"PlanetOrbits.accdec","text":"accdec(orbit, t)\n\nGet the instantaneous acceleration [mas/julian year^2] in the right-ascension direction of the secondary at the time t [days].\n\naccdec(o)\n\nGet the instantaneous acceleration [mas/julian year^2] in the right-ascension direction of the secondary from an instance of AbstractOrbitSolution.\n\naccdec(elem, t, M_planet)\n\nGet the instantaneous acceleration [mas/julian year^2] in the right-ascension direction of  the primary in at the time t [days]. The units of M_planet and elem.M must match.\n\naccdec(o)\n\nGet the instantaneous acceleration [mas/julian year^2] in the right-ascension direction of the primary from an instance of AbstractOrbitSolution. The units of M_planet and elem.M must match.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.accra","page":"API","title":"PlanetOrbits.accra","text":"accra(orbit, t)\n\nGet the instantaneous acceleration [mas/julian year^2] in the right-ascension direction of the secondary at the time t [days].\n\naccra(o)\n\nGet the instantaneous acceleration [mas/julian year^2] in the right-ascension direction of the secondary from an instance of AbstractOrbitSolution.\n\naccra(elem, t, M_planet)\n\nGet the instantaneous acceleration [mas/julian year^2] in the right-ascension direction of  the primary in at the time t [days]. The units of M_planet and elem.M must match.\n\naccra(o)\n\nGet the instantaneous acceleration [mas/julian year^2] in the right-ascension direction of the primary from an instance of AbstractOrbitSolution. The units of M_planet and elem.M must match.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.apoapsis-Tuple{AbstractOrbit}","page":"API","title":"PlanetOrbits.apoapsis","text":"apoapsis(orbit)\n\nReturn the apoapsis of an orbit in AU.\n\nKeywords: apoastron, apohelion, apogee\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.astuple-Tuple{KepOrbit}","page":"API","title":"PlanetOrbits.astuple","text":"astuple(elements)\n\nReturn the parameters of a KepOrbit value as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.compensate_star_3d_motion-Tuple{PlanetOrbits.AbsoluteVisualOrbit, Number}","page":"API","title":"PlanetOrbits.compensate_star_3d_motion","text":"This function calculates how to account for stellar 3D motion  when comparing measurements across epochs (epoch1 vs epoch2).\n\nTypically epoch1 is your reference epoch, epoch2 is your measurement epoch, and the remaining parameters are parameters you are hoping to fit. You use this function to calculate their compensated values, and compare these to data at epoch2.\n\nWill also calculates light travel time, returning updated epochs (epoch2a) due to change in distance between epoch1 and epoch2. epoch2 will be when the light was detected, epoch2a will be the \"emitted\" time accounting for the different positions between epoch1 and epoch 2.\n\nOriginal Author: Eric Nielsen\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.dec-Tuple{PlanetOrbits.OrbitSolutionAbsoluteVisual, Any}","page":"API","title":"PlanetOrbits.dec","text":"PlanetOrbits.dec(orbit, t)\n\nGet the instantaneous position of a companion in degrees of RA and Dec.  For the relative position, see decoff.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.decoff","page":"API","title":"PlanetOrbits.decoff","text":"decoff(orbit, t)\n\nGet the offset [mas] from the primary body in Declination at the time t [days].\n\ndecoff(orbit, t)\n\nGet the offset [mas] from the primary body in Declination from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.distance","page":"API","title":"PlanetOrbits.distance","text":"distance(orbit)\n\nDistance to the system [pc].\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.eccanom-Tuple{AbstractOrbitSolution}","page":"API","title":"PlanetOrbits.eccanom","text":"eccanom(orbit, t)\n\nGet the eccentric anomaly [radians] of the secondary at the time t [days].\n\neccanom(o)\n\nGet the eccentric anomaly [radians] of the secondary from an instance of AbstractOrbitSolution.\n\nNote that for hyperbolic orbits, eccentric anomaly is not defined and the hyperbolic anomaly is returned instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.eccentricity","page":"API","title":"PlanetOrbits.eccentricity","text":"eccentricity(orbit)\n\nEccentricity of an orbit, between 0 and 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.inclination","page":"API","title":"PlanetOrbits.inclination","text":"inclination(orbit)\n\nInclination of an orbit, if available [rad].\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.meananom-Tuple{AbstractOrbitSolution}","page":"API","title":"PlanetOrbits.meananom","text":"meananom(orbit, t)\n\nGet the mean anomaly [radians] of the secondary at the time t [days].\n\nmeananom(o)\n\nGet the mean anomaly [radians] of the secondary from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.meanmotion","page":"API","title":"PlanetOrbits.meanmotion","text":"meanmotion(orbit)\n\nMean motion [rad/julian year].\n\nNote: a 1 AU (IAU) orbit around a 1Msun (IAU) star has a period just over 1 julian year.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.mjd-Tuple{AbstractString}","page":"API","title":"PlanetOrbits.mjd","text":"mjd(\"2020-01-01\")\n\nGet the modfied julian day of a date, or in general a UTC timestamp.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.mjd-Tuple{Union{Dates.Date, Dates.DateTime}}","page":"API","title":"PlanetOrbits.mjd","text":"mjd(Date(\"2020-01-01\"))\n\nGet the modfied julian day of a Date or DateTime object.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.mjd-Tuple{}","page":"API","title":"PlanetOrbits.mjd","text":"mjd()\n\nGet the current modified julian day of right now.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.mjd2date-Tuple{Any}","page":"API","title":"PlanetOrbits.mjd2date","text":"mjd2date(modified_julian)\n\nGet a Date value from a modfied julian day, rounded to closest day\n\nExamples\n\njulia> mjd2date(59160.8)\n2020-11-08\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.orbit-Tuple{}","page":"API","title":"PlanetOrbits.orbit","text":"orbit(...)\n\nConstruct an orbit from the provided keyword arguments. Will automatically select a subclass of AbstractOrbit based on the information provided. This is a convenience function that is not type stable and should not be used in performance sensitive contexts. Instead, call one of the concrete constructors KepOrbit, VisualOrbit, or RadialVelocityOrbit directly. This function logs the kind of elements created so that it's easy to select the correct constructor.\n\nRequired arguments:\n\na: semi-major axis [AU]\nM: gravitational parameter [M⊙]\n\nOptional arguments:\n\ntp: epoch of periastron passage, default=0\ne: eccentricity, default=0\nω: argument of periapsis [rad], default=0\ni: inclination [rad]\nΩ: longitude of ascending node [rad]\nplx: parallax [mas]; defines the distance to the primary\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.orbitsolve","page":"API","title":"PlanetOrbits.orbitsolve","text":"orbitsolve(orbit, t, method=Auto())\n\nGiven an orbit object and a time t in days, get the position and velocity of the secondary body (e.g. planet around a star).\n\nThis will output a struct that is a subtype of AbstractOrbitSolution which we can then query with raoff, decoff, radvel, etc.\n\nYou can also calculate those quanitities individually (see their docstrings)  but if you need more than one, it is most efficient to save the orbit solution once.\n\nNote: these calculations use the small angle approximation, so are only accurate when  the star is much further way from the observer than the secondary is from the primary.\n\nSee also: orbitsolve_ν,  orbitsolve_meananom,  orbitsolve_eccanom, projectedseparation, raoff, decoff, radvel, propmotionanom.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.orbitsolve_eccanom-Tuple{AbstractOrbit, Any}","page":"API","title":"PlanetOrbits.orbitsolve_eccanom","text":"orbitsolve_eccanom(elements, EA)\n\nSame as orbitsolve, but solves orbit for a given eccentric anomaly instead of time.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.orbitsolve_meananom-Tuple{AbstractOrbit, Any}","page":"API","title":"PlanetOrbits.orbitsolve_meananom","text":"orbitsolve_meananom(elements, MA)\n\nSame as orbitsolve, but solves orbit for a given mean anomaly instead of time.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.orbitsolve_ν","page":"API","title":"PlanetOrbits.orbitsolve_ν","text":"orbitsolve_ν(elem, ν)\n\nSolve a keplerian orbit from a given true anomaly [rad]. See orbitsolve for the same function accepting a given time.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.orbitsolve_ν-2","page":"API","title":"PlanetOrbits.orbitsolve_ν","text":"orbitsolve_ν(elem, ν, EA)\n\nSolve an orbit from a given true anomaly [rad]. See orbitsolve for the same function accepting a given time. Can optionally pass eccentric anomaly (EA) if already computed.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.periapsis-Tuple{AbstractOrbit}","page":"API","title":"PlanetOrbits.periapsis","text":"periapsis(orbit)\n\nReturn the periapsis of an orbit in AU.\n\nKeywords: periastron, perihelion, perigee\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.periastron","page":"API","title":"PlanetOrbits.periastron","text":"periastron(elements)\n\nCompute the MJD of periastron passage most recently after the reference epoch tref specified in the orbit. N.B. mjd of 58849 = 2020-01-01\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.period","page":"API","title":"PlanetOrbits.period","text":"period(orbit)\n\nPeriod of an orbit [days].\n\nNote: a 1 AU (IAU) orbit around a 1Msun (IAU) star has a period just over 1 julian year.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.pmdec","page":"API","title":"PlanetOrbits.pmdec","text":"pmdec(orbit, t)\n\nGet the instantaneous proper motion anomaly [mas/julian year] in declination of the secondary at the time t [days].\n\npmdec(o)\n\nGet the instantaneous proper motion anomaly [mas/julian year] in declination of the secondary from an instance of AbstractOrbitSolution.\n\npmdec(elem, t, M_planet)\n\nGet the instantaneous proper motion anomaly [mas/julian year] in declination of  the primary in at the time t [days]. The units of M_planet and elem.M must match.\n\npmdec(o, M_planet)\n\nSame as above, but from an orbit solution.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.pmra","page":"API","title":"PlanetOrbits.pmra","text":"pmra(orbit, t)\n\nGet the instantaneous proper motion anomaly [mas/julian year] in right-ascension of the secondary at the time t [days].\n\npmra(o)\n\nGet the instantaneous proper motion anomaly [mas/julian year] in right-ascension of the secondary from an instance of AbstractOrbitSolution.\n\npmra(elem, t, M_planet)\n\nGet the instantaneous proper motion anomaly [mas/julian year] in right-ascension of  the primary in at the time t [days]. The units of M_planet and elem.M must match.\n\npmra(o, M_planet)\n\nSame as above, but from an orbit solution.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.posangle-Tuple{AbstractOrbitSolution}","page":"API","title":"PlanetOrbits.posangle","text":"posangle(orbit, t)\n\nCalculate the position angle [rad] of the secondary about its primary from our perspective at the time t [days].\n\nposangle(o)\n\nCalculate the position angle [rad] of the secondary about its primary from our perspective from an instance of AbstractOrbitSolution.\n\nposangle(elem, t, M_planet)\n\nCalculate the position angle [rad] of the secondary about its primary from our perspective at the time t [days]. In this case only, the value of M_planet can be arbitrary.\n\nposangle(o, M_planet)\n\nCalculate the position angle [rad] of the primary  from our perspective from an instance of AbstractOrbitSolution. In this case only, the value of M_planet can be arbitrary.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.posx","page":"API","title":"PlanetOrbits.posx","text":"posx(orbit, t)\n\nGet the offset [AU] from the primary body at the time t [days].\n\nposx(orbit, t)\n\nSame as above, but from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.posx-Tuple{Union{PlanetOrbits.OrbitSolutionCartesian, PlanetOrbits.OrbitSolutionKep}}","page":"API","title":"PlanetOrbits.posx","text":"Get the position in the x direction in astronomical units.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.posy","page":"API","title":"PlanetOrbits.posy","text":"posy(orbit, t)\n\nGet the offset [AU] from the primary body at the time t [days].\n\nposy(o)\n\nSame as above, but from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.posy-Tuple{Union{PlanetOrbits.OrbitSolutionCartesian, PlanetOrbits.OrbitSolutionKep}}","page":"API","title":"PlanetOrbits.posy","text":"Get the position in the y direction in astronomical units.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.posz","page":"API","title":"PlanetOrbits.posz","text":"posz(orbit, t)\n\nGet the offset [AU] from the primary body at the time t [days].\n\nposz(o)\n\nSame as above, but from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.posz-Tuple{Union{PlanetOrbits.OrbitSolutionCartesian, PlanetOrbits.OrbitSolutionKep}}","page":"API","title":"PlanetOrbits.posz","text":"Get the position in the z direction in astronomical units.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.projectedseparation-Tuple{AbstractOrbitSolution}","page":"API","title":"PlanetOrbits.projectedseparation","text":"projectedseparation(orbit, t)\n\nCalculate the projected separation [mas] of the secondary from its primary at the time t [days].\n\nprojectedseparation(o)\n\nCalculate the projected separation [mas] of the secondary from its primary from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.ra-Tuple{PlanetOrbits.OrbitSolutionAbsoluteVisual, Any}","page":"API","title":"PlanetOrbits.ra","text":"PlanetOrbits.ra(orbit, t)\n\nGet the instantaneous position of a companion in degrees of RA and Dec.  For the relative position, see raoff.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.radvel","page":"API","title":"PlanetOrbits.radvel","text":"radvel(orbit, t)\n\nGet the relative radial velocity [m/s] of the  secondary vs the primary along the line of sight (positive meaning moving away) at the time t [days].\n\nradvel(o)\n\nGet the relative radial velocity [m/s] of the  secondary vs the primary along the line of sight (positive meaning moving away) from an instance of AbstractOrbitSolution.\n\nradvel(elem, t, M_planet)\n\nGet the absolute radial velocity [m/s] of the  primary long the line of sight (positive meaning moving away) at the time t [days]. The units of M_planet and elem.M must match.\n\nradvel(o, M_planet)\n\nGet the absolute radial velocity [m/s] of the primary along the line of sight (positive meaning moving away) from an AbstractOrbitSolution. The units of M_planet and elem.M must match.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.raoff","page":"API","title":"PlanetOrbits.raoff","text":"raoff(orbit, t)\n\nGet the offset [mas] from the primary body in Right Ascension at the time t [days].\n\nraoff(o)\n\nGet the offset [mas] from the primary body in Right Ascension  from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.semiamplitude","page":"API","title":"PlanetOrbits.semiamplitude","text":"semiamplitude(orbit)\n\nRadial velocity semiamplitude [m/s].\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.semimajoraxis","page":"API","title":"PlanetOrbits.semimajoraxis","text":"semimajoraxis(orbit)\n\nSemi-major axis of an orbit, if available [au].\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.semiminoraxis-Tuple{AbstractOrbit}","page":"API","title":"PlanetOrbits.semiminoraxis","text":"semiminoraxis(orbit)\n\nReturn the semi-minor axis of an orbit in AU.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.totalmass","page":"API","title":"PlanetOrbits.totalmass","text":"totalmass(orbit)\n\nTotal mass of the system in solar masses\n\n\n\n\n\n","category":"function"},{"location":"api/#PlanetOrbits.trueanom-Tuple{AbstractOrbitSolution}","page":"API","title":"PlanetOrbits.trueanom","text":"trueanom(orbit, t)\n\nGet the true anomaly [radians] of the secondary at the time t [days].\n\ntrueanom(o)\n\nGet the true anomaly [radians] of the secondary from an instance of AbstractOrbitSolution.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.velx-Tuple{Union{PlanetOrbits.OrbitSolutionCartesian, PlanetOrbits.OrbitSolutionKep}}","page":"API","title":"PlanetOrbits.velx","text":"Get the velocity in the x direction in astronomical units / julian year.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.vely-Tuple{Union{PlanetOrbits.OrbitSolutionCartesian, PlanetOrbits.OrbitSolutionKep}}","page":"API","title":"PlanetOrbits.vely","text":"Get the velocity in the y direction in astronomical units / julian year.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.velz-Tuple{Union{PlanetOrbits.OrbitSolutionCartesian, PlanetOrbits.OrbitSolutionKep, OrbitSolutionRadialVelocity}}","page":"API","title":"PlanetOrbits.velz","text":"Get the velocity in the z direction in astronomical units / julian year.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlanetOrbits.years2mjd-Tuple{Any}","page":"API","title":"PlanetOrbits.years2mjd","text":"years2mjd()\n\nConvert from decimal years (e.g. 1995.25) into modified julian date, rounded to closest second\n\n\n\n\n\n","category":"method"},{"location":"conventions/#Units-and-Conventions","page":"Conventions","title":"Units & Conventions","text":"","category":"section"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The main constructor, Visual{KepOrbit}, accepts the following parameters:","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"a: Semi-major axis in astronomical units (AU)\ni: Inclination in radians\ne: Eccentricity in the range [0, 1)\ntp: Epoch of periastron passage in days (specifically, referenced to modified julian date)\nM: Graviataion parameter of the central body, expressed in units of Solar mass.\nω: Argument of periastron\nΩ: Longitude of the ascending node, radians.\nplx: Distance to the system expressed in milliarcseconds of parallax.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"Parameters can either be specified by position or as keyword arguments (but not a mix).","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"(Image: )","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"This diagram shows a circular (gray), inclined (blue), and inclined eccentric (green) orbits described using the conventions of this package.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The x variable increases to the left in the plane of the sky, consistent with right ascension that increases towards the East. The y coordinate increases upwards towards the North. The z coordinate increases away from the observer.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The ascending node is measured CCW in the plane of the sky starting from the y (North) axis.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"The location of the planet along its ellipse is measured along the green ellipse starting from periastron. The parameter tp describes a date at which the planet made its closest approach to the star, and therefore sets the location of the planet at a given time. For bound (circular or elliptical) orbits there are infinitely many equivalent tp values, related by t_pprime = t_p i P where P is the period of the planet.","category":"page"},{"location":"conventions/","page":"Conventions","title":"Conventions","text":"See this PDF for a detailed derivation of projected position, velocity, and acceleration from these coordinates: Derivation.pdf","category":"page"},{"location":"conversions/#Converting-Between-Orbit-Types","page":"Conversions","title":"Converting Between Orbit Types","text":"","category":"section"},{"location":"conversions/","page":"Conversions","title":"Conversions","text":"You can convert between several of the supported orbit types.","category":"page"},{"location":"conversions/","page":"Conversions","title":"Conversions","text":"Examples:","category":"page"},{"location":"conversions/","page":"Conversions","title":"Conversions","text":"using PlanetOrbits, Plots\n\n\n# Specify a Visual{KepOrbit}\norb_vis = Visual{KepOrbit}(M=1, e=0.4, a=1, i=2, Ω=3, ω=1, tp=0, plx=10.0);\n\n# Convert to Thiele-Innes\norb_ti = ThieleInnesOrbit(orb_vis)\n\n# Convert back to Visual{KepOrbit}\norb_vis2 = Visual{KepOrbit}(orb_ti)\n\n# Convert to a CartesianOrbit (specified by position and velocity)\n# We have to solve the orbit at a particular time (or true anomally, mean anomally, etc)\n# Then we can use that solution to construct a CartesianOrbit\norb_vis_sol = orbitsolve(orb_vis,0)\norb_cart = CartesianOrbit(orb_vis_sol; tol=1e-4) # default is 1e-8\n\n# Solve each orbit at the same date\ntime = mjd(\"2023-01-01\")\n\nsol_vis =   orbitsolve(orb_vis, time)\nsol_ti =    orbitsolve(orb_ti, time)\nsol_vis2 =  orbitsolve(orb_vis2, time)\nsol_cart =  orbitsolve(orb_cart, time)\n\nplot( aspectratio=1, legend=:none,)\nxlims!(-1.5,1.5)\nylims!(-1.5,1.5)\nzlims!(-1.5,1.5)\n\nplot!(sol_vis,  color=1, lw=10, ms=10, kind=(:x,:y,:z))\nplot!(sol_ti,   color=2, lw=6, ms=6,   kind=(:x,:y,:z))\nplot!(sol_vis2, color=3,  lw=3, ms=3,  kind=(:x,:y,:z))\nplot!(sol_cart, color=4,  lw=1, ms=1,  kind=(:x,:y,:z))\n\nscatter!([0], [0], [0], marker=:circle,  color=:white, ms=6)","category":"page"},{"location":"conversions/","page":"Conversions","title":"Conversions","text":"When converting to a CartesianOrbit, the tol parameter controls how near-equitorial and near-circular orbits are handled.  If eccentricity is below tol, then it is zeroed and the orbit is treated as circular (changing how ω is set). If the absolute value of inclination is below tol, then it is zeroed and the orbit is treated as equatorial (changing how Ω is set).","category":"page"},{"location":"hyperbolic/#Hyperbolic-Orbits","page":"Hyperbolic","title":"Hyperbolic Orbits","text":"","category":"section"},{"location":"hyperbolic/","page":"Hyperbolic","title":"Hyperbolic","text":"PlanetOrbits.jl has preliminary support for hyperbolic orbits. They are currently supported with KepOrbit and CartesianOrbit but not ThieleInnesOrbit.","category":"page"},{"location":"hyperbolic/","page":"Hyperbolic","title":"Hyperbolic","text":"using PlanetOrbits, Plots\n\n# Specify orbit with a Campbell parameters (KepOrbit)\norb = orbit(M=1, e=1.1, a=1, i=2, Ω=3, ω=1, tp=mjd(\"2024-01-01\"));\nsol = orbitsolve(orb, mjd(\"2024-3-01\"))\nplot(sol, tspan=mjd(\"2024-01-01\") .+ (-300,100))\n","category":"page"},{"location":"hyperbolic/","page":"Hyperbolic","title":"Hyperbolic","text":"using PlanetOrbits, Plots\n\n# Specify orbit with a state vector (CartesianOrbit)\norb = orbit(\n    x = 1.0,\n    y = 0.3,\n    z = 0.001,\n    vx = 0,\n    vy = 9,\n    vz = 0.0,\n    M = 1,\n    tref = mjd(\"2024-01-01\")\n)\nsol = orbitsolve(orb, mjd(\"2024-3-01\"))\nplot(sol, tspan=mjd(\"2024-01-01\") .+ (-300,100))","category":"page"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"This package is structured around a representation of an orbit (PlanetOrbits.AbstractOrbit, and a representation of a \"solved\" orbit (PlanetOrbits.AbstractOrbitSolution).","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"You start by creating an orbit with known information, e.g. the semi-major axis and eccentricity. You can then query information from this orbit, like its orbital period, mean motion, or periastron (closest approach). Then, you can \"solve\" the orbit one more times for a given time, eccentric anomaly, or true anomaly.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Let's see how this works.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"using PlanetOrbits, Plots\norb = orbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The orbit function accepts many combinations of orbital parameters and returns a subtype of PlanetOrbits.AbstractOrbit.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can now query some basic properties about the orbit:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"period(orb) # orbital period (days)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"meanmotion(orb) # Mean motion (radians/yr)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"periastron(orb) # Epoch of periastron passage (MJD)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"semiamplitude(orb) # radial velocity semi-amplitude (m/s)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can plot the orbit (more on this in Plotting):","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"plot(orb)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"And we can solve the orbit for a given orbital location","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"sol = orbitsolve_ν(orb, 0.1)        # true anomaly (radians)\nsol = orbitsolve_eccanom(orb, 0.1)  # eccentric anomaly (radians)\nsol = orbitsolve_meananom(orb, 0.1) # mean anomaly (radians)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"When constructing an orbit, the location of the planet along its orbit can be specified by tp. This is the (or a) time the planet made its closest approach to the star.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"orb = orbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n    tp=mjd(\"2020-04-15\"),\n);","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can now meaningfully solve the location of the planet at a specific time:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"t = mjd(\"2020-07-15\") # date as in modified julian days.\nsol = orbitsolve(orb, t) # can optionally pass `tref=...` ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can query specifics at this solution:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"trueanom(sol) # true anomaly (radians)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"eccanom(sol) # eccentric anomaly (radians)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"plot(sol) # defaults to kind=:radvel for RadialVelocityOrbit","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Notice that we now see a marker at the location found by orbitsolve.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can create an orbit with some eccentricity. If not specified, eccentricity and the argument or periapsis default to 0 for any orbit type.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"orb = orbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n    tp=mjd(\"2020-04-15\"),\n    # New:\n    e=0.6, # eccentricity\n    ω=2.5, # argument of periapsis (radians)\n)\nplot(orb) # defaults to kind=:radvel for RadialVelocityOrbit","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"warning: ω convention\nThe convention used in this package is that ω, the argument of periapsis, refers to the secondary body. This is in contrast to the typical standard adopted in the radial velocity literature where ω refers to the primary. You can convert by adding or subtracting 180°.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Since we only provided very minimal information to the orbit function, we've been receiving a RadialVelocityOrbit. This object contains sufficient information to calculate the above radial velocity plots, orbital period, etc., but not the 3D position in space.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Let's create a new orbit with a specified inclination and longitude of ascending node.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"orb = orbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n    tp=mjd(\"2020-04-15\"),\n    e=0.6, # eccentricity\n    ω=2.5, # argument of periapsis (radians)\n    # New:\n    i=0.6, # inclination (radians)\n    Ω=2.3, # inclination (radians)\n)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"This time we received a full KepOrbit. This has the necessary information to solve the orbit in 2/3D.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"plot(orb) # defaults to kind=(:x,:y) for KepOrbit","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"plot(orb, kind=(:x,:y,:z))","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"note: Cartesian convention\nThe convention used in this package is that x increases to the left (just like right-ascension), and the z increases away from the observer.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can solve for a time or location as usual.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"sol = orbitsolve(orb, mjd(\"2025-01\"))","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"eccanom(sol) # eccentric anomaly (radians)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can also query the cartesian position of the planet in AU:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"PlanetOrbits.posx(sol)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"PlanetOrbits.posy(sol)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"PlanetOrbits.posy(sol)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"plot(sol)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"plot(sol, kind=:x)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We can still of course calculate the radial velocity as well.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"radvel(sol)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"plot(sol, kind=:radvel)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Finally, we'll specify the parallax distance to the system. This will allow us to plot orbits with angular units as they would appear in the sky from the Earth.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"orb = orbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n    tp=mjd(\"2020-04-15\"),\n    e=0.6, # eccentricity\n    ω=2.5, # argument of periapsis (radians)\n    i=0.6, # inclination (radians)\n    Ω=2.3, # inclination (radians)\n    # New:\n    plx=100.0 # parallax distance (milliarcseconds)\n)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"sol = orbitsolve(orb, 0.0)\nplot(sol)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"posangle(sol) # position angle offset from barycentre (milliarcseconds)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"projectedseparation(sol) # separation from barycentre (milliarcseconds)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"raoff(sol) # right ascension offset from barycentre (milliarcseconds)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"decoff(sol) # declination offset from barycentre (milliarcseconds)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"raoff(sol) # right ascension offset from barycentre (milliarcseconds)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"decoff(sol) # declination offset from barycentre (milliarcseconds)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"pmra(sol) # instantaneous right ascension velocity from barycentre (milliarcseconds/year)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"pmdec(sol) # instantaneous declination velocity from barycentre (milliarcseconds/year)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"accra(sol) # instantaneous right ascension acceleration from barycentre (milliarcseconds/year^2)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"accdec(sol) # instantaneous declination acceleration from barycentre (milliarcseconds/year^2)","category":"page"},{"location":"introduction/#Performance","page":"Introduction","title":"Performance","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The orbit function is a convenience only for interactive use. It is inefficient since it is not type-stable. Instead, one should use one of the orbit constructors directly. For example, instead of ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"orb = orbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n    tp=mjd(\"2020-04-15\"),\n    e=0.6, # eccentricity\n    ω=2.5, # argument of periapsis (radians)\n    i=0.6, # inclination (radians)\n    Ω=2.3, # inclination (radians)\n) # Not type stable","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Use:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"orb = KepOrbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n    tp=mjd(\"2020-04-15\"),\n    e=0.6, # eccentricity\n    ω=2.5, # argument of periapsis (radians)\n    i=0.6, # inclination (radians)\n    Ω=2.3, # inclination (radians)\n    plx=100.0 # parallax distance (milliarcseconds)\n) # Type stable","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"This will prevent ‪unnecessary‬ allocations in some cases.","category":"page"},{"location":"introduction/#Convenience","page":"Introduction","title":"Convenience","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"All functions described above that apply to orbit solutions can be called directly on an orbit along with a time in days:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"orb = orbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses),\n)\nradvel(orb, mjd(\"2025-01-01\"))","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"If you need to calculate many different properties, e.g. both x and y position at a given time/location, it is more efficient to calculate the orbit solution a single time and query the result as needed.","category":"page"},{"location":"introduction/#Host-calculations","page":"Introduction","title":"Host calculations","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The above calculations treat the planet as a test particle and calculate their displacement/velocity/etc. compared to the two-particle system's barycentre. If you wish to calculate the same properties for the host object, you can additionally supply the mass of the planet.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"orb = orbit(\n    a=1.0, # semi major axis (AU)\n    M=1.0, # primary mass (solar masses)\n    i=0.5,\n    Ω=2.5,\n    plx=100.0\n)\nsol = orbitsolve(orb, mjd(\"2025-01-01\"))\n# Secondary radial velocity\nradvel(sol)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"# Primary radial velocity\nradvel(sol, 0.1) # 0.1 solar mass secondary","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The following show pairs of results for the secondary and the primary:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"PlanetOrbits.posx(sol), PlanetOrbits.posx(sol, 0.1)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"radvel(sol), radvel(sol, 0.1)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"raoff(sol), raoff(sol, 0.1)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"accra(sol), accra(sol, 0.1)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"projectedseparation(sol), projectedseparation(sol, 0.1)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"posangle(sol), posangle(sol, 0.1)","category":"page"},{"location":"#PlanetOrbits.jl","page":"Home","title":"PlanetOrbits.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: GitHub)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tools for solving Keplerian orbits, especially in the context of exoplanet detection and modelling. The functions of this package allow one to propagate two-body orbits using a variety of orbital basis sets (classic Campbell, Thiele-Innes, and Cartesian state-vectors.). A fully featured A Plots.jl recipe is included for easily plotting different orbit properties in space or time, or against other variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bound circular and elliptical orbits are fully supported. Support for hyperbolic orbits is experimental.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Among other uses, it can be used to calculates the projected positions of planets, radial velocity, and proper motion anomaly. It is also a great tool for visualizing different orbits (see examples) and generating nice animations (e.g. with Plots or Luxor.jl).","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package has been designed for good performance and composability with a wide range of packages in the Julia ecosystem. Automatic differentiation with ForwardDiff, Enzyme, and Zygote are supported. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"A variety of Kepler solvers are provided. Arbitrary precision can be achieved by specifying orbits using Julia's built in BigFloat datatype and using a solver with user-specified tolerance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To fit orbits to observations, see Octofitter.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also AstroImages.jl.","category":"page"},{"location":"#Attribution","page":"Home","title":"Attribution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find this package useful in your research, please cite the following paper (open-access link).","category":"page"},{"location":"","page":"Home","title":"Home","text":"This software package contains calculations that are adapted from various open source packages, including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"NASA/JPL SPICE (public domain)\nkeplerorbit.py by Spencer Wallace (MIT license)\nPoliaAstro (MIT license)\nOrbitize by Blunt et al. (BSD 3-Clause License)\nRadVel by Fulton et al. (MIT license)","category":"page"},{"location":"","page":"Home","title":"Home","text":"These codes were useful references in the development of this package but are not redistributed.","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"introdcution.md\", \"plots.md\", \"image-warping.md\"]\nDepth = 5","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"api.md\", \"conventions.md\", \"kepler.md\"]\nDepth = 5","category":"page"},{"location":"","page":"Home","title":"Home","text":"<video src=\"assets/51-eri-orbit.mp4\" autoplay loop width=300 height=300>","category":"page"},{"location":"kepler/#Kepler-Solvers","page":"Kepler Solvers","title":"Kepler Solvers","text":"","category":"section"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"The heart of this package is being able to take a set of Keplerian elements and output relative positions, velocities, etc.","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"This normaly requires solving Kepler's equation numerically. This package supports a multitude of solver algorithms that can be passed to orbitsolve:","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"PlanetOrbits.Auto\nPlanetOrbits.Markley\nPlanetOrbits.Goat\nPlanetOrbits.RootsMethod","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"The last of these RootsMethod, allows one to substitute any algorithm from the Roots.jl package. These include many different classical and modern root finding algorithms.chosen precision, including artibrary precision BigFloats. Using big floats with, for example, Roots.PlanetOrbits.Thukral5B and a tight tolerenace, allows you to solve orbits up to arbitrary precision.","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"The default choice is Auto, which currently selects Markley for all cases. The Markley algorithm is very fast, reasonably accurate, and always converges, making it a good default choice.","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"The Markley algorithm is a tweaked version of the algorithm from AstroLib.jl. It is non-iterative and converges with less than 1e-15 relative error across the full range of e between 0 and 1. On my laptop, this solves for a single eccentric anomaly in just 71 ns. Since it is implemented in pure Julia, there is no overhead from calling into a C or Cython compiled function and no need for vectorization.","category":"page"},{"location":"kepler/#Examples","page":"Kepler Solvers","title":"Examples","text":"","category":"section"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"using PlanetOrbits, BenchmarkTools\norb = orbit(a=1.2, e=0.1, M=1.0, ω=1.4, τ=0.5)\nt = mjd(\"2025-06-23\")\n@benchmark orbitsolve(orb, t, PlanetOrbits.Markley())","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"@benchmark orbitsolve(orb, t, PlanetOrbits.Goat())","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"using Roots\n@benchmark orbitsolve(orb, t, PlanetOrbits.RootsMethod(Roots.Newton()))","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"using Roots\n@benchmark orbitsolve(orb, t, PlanetOrbits.RootsMethod(Roots.Thukral3B()))","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"@benchmark orbitsolve(orb, t, PlanetOrbits.RootsMethod(Roots.A42()))","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"@benchmark orbitsolve(orb, t, PlanetOrbits.RootsMethod(Roots.Bisection()))","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"@benchmark orbitsolve(orb, t, PlanetOrbits.RootsMethod(Roots.SuperHalley()))","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"@benchmark orbitsolve(orb, t, PlanetOrbits.RootsMethod(Roots.Brent()))","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"@benchmark orbitsolve(orb, t, PlanetOrbits.RootsMethod(Roots.Order2()))","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"@benchmark orbitsolve(orb, t, PlanetOrbits.RootsMethod(Roots.AlefeldPotraShi()))","category":"page"},{"location":"kepler/#High-precision","page":"Kepler Solvers","title":"High precision","text":"","category":"section"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"You can solve Kepler's equation in high precision using big floats and tightening the tolerance on the solver.","category":"page"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"orb_big = orbit(a=big(1.2), e=big(0.1), M=big(1.0), ω=big(1.4), τ=big(0.5))\nsol = orbitsolve(orb_big, big(t), PlanetOrbits.RootsMethod(Roots.Thukral5B(),rtol=1e-30,atol=1e-30,))\nradvel(sol)","category":"page"},{"location":"kepler/#Comparison","page":"Kepler Solvers","title":"Comparison","text":"","category":"section"},{"location":"kepler/","page":"Kepler Solvers","title":"Kepler Solvers","text":"(Image: ) (Image: )","category":"page"}]
}
